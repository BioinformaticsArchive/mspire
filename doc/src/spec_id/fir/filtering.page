---
title: Filtering
inMenu: true
directoryName: Filtering
---
Filtering SEQUEST hits
----------------------

mspire can be used for classical filtering of SEQUEST hits based on varying hit parameters.  Here is the basic usage (following are more detailed examples):

    require 'spec_id/precision/filter'

    specid = SpecID.new( %w(file1.srf file2.srf) )  # create a specID object
    fir_finder = SpecID::Precision.Filter.new
    options = {...}  # lots of options to consider :)
    answer = fir_finder.filter_and_validate(specid, options)
    answer[:pephits]            # => SpecID::Pep objects passing the filter
    answer[:pephits_precision]  # => fraction of correct hits

### Separate DB search

We first start out by creating some validators that will be used to judge the accuracy of our peptide hits.  Assuming we had done two separate DB searches, we would make a Decoy validator like this:

    val = Validator::Decoy.new(
          :decoy_to_target_ratio => 1.0,  # usually 1.0
          :constraint => "filename.srg",  # the meta-file pointing to decoy runs
        )

Make some options:

    options = {
        :top_hit_by => :xcorr,        # top hit by XCorr
        :postfilter => :top_per_scan, # after filtering, report top hit per scan
        :output => [:yaml,nil]        # format output as YAML and send to STDOUT
        :sequest => {
          :xcorr1 => 1.5,   #  >= xcorr +1 charge state
          :xcorr2 => 2.5,   #  >= xcorr +2 charge state
          :xcorr3 => 3.5,   #  >= xcorr +3 (or higher) charge state
          :deltacn => 0.25, # minimum deltacn required
          :ppm => 12.0,      # parts per million (~10 for Orbi, ~1200 for LCQ)
          :include_deltacnstar => true  # top hit with no 2nd hit included
        }

        :validators => [val]
        }
    
Run it:

    fir_finder = SpecID::Precision.Filter.new
    answer = fir_finder.filter_and_validate(specid, options) # specid of normal hits
    answer[:pephits]            # => SpecID::Pep objects passing the filter
    answer[:pephits_precision]  # => fraction of correct hits

#### Method of calculation

The FIR is calculated: foreach decoy peptide passing the filtering threshold, a target peptide is incorrect.  The final precision is given only in terms of the target peptides.

#### On the commandline:

A command line interface is also provided:

    filter_and_validate.rb    # to get usage information

    # this command will calculate precision exactly as described above:
    filter_and_validate.rb -1 1.5 -2 2.5 -3 3.5 -d 0.25 -p 12.0 \
         --decoy filename.srg --post_filter top_per_scan \
         file1.srf file2.srf

    # the interactive switch is handy for playing around with data
    # (make sure to include --interactive_verbose first few times
     filter_and_validate.rb ... -i --interactive_verbose ...

    # you can give the interactive switch a filename with filters
     filter_and_validate.rb ... -i list_of_filters.txt ...

    < inside list_of_filters.txt >
     x1:1.5 x2:2.5 x3:3.5 dcn:0.25 ppm:12.0
     x1:1.8 x2:2.8 x3:3.9 dcn:0.30 ppm:15.0
     # or just a list of numbers in the same order:
     1.8 2.8 3.9 0.30 15.0

### Concatenated DB search

Many folks like to search with a concatenated DB.  This is run exactly the
same as above with one exception: the constraint should be a *Regexp* (that
matches the fasta header line after the leading '>':

     val = Validator::Decoy.new(
          :constraint => /^DECOY_/,
          # to match proteins from a header like this:
          # >DECOY_gi|125432345|323455 "Acetyl Co..."
        )
    # everything else is the same...

#### Method of calculation

The FIR is calculated for the *target* peptides in the same manner as in the
separate search: foreach decoy peptide hit passing the filters, a target
peptide hit is considered incorrect.  Again, the precision of the target hits
is reported independent of the decoy hits (except as they inform the target
hits of their accuracy).

#### Commandline

Again, everything is the same as the separate search, only we give a regular expression on the commandline instead of a filename:

    filter_and_validate.rb -1 1.5 -2 2.5 -3 3.5 -d 0.25 -p 12.0 \
         --decoy '/^DECOY/' --post_filter top_per_scan \
         file1.srf file2.srf
    
    # note that the relevant bit is after the --decoy flag 
    # the regular expression must be between slashes so it is interpreted as 
    # a regular expression and not a filename!

