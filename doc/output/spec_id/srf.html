<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>SRF</title>
    <link href="../default.css" rel="stylesheet" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  </head>
  <body>
    <div id="logo">
        <a href=../index.html><img src=../images/mspire_logo.png border="0" alt="mspire - mass spectrometry proteomics in ruby"/></a>
  </div>
    <div id="header">
      <h1>SRF</h1>
    </div>

    <div id="headerbar" class="bar">
        <!-- <span class="left">Location: <a href="../index.html" title="mspire">mspire</a> / <a href="./index.html" title="SpecID">SpecID</a> / <a href="./srf.html" title="SRF">SRF</a></span> -->
      <!--<span class="right">Language: <a href="./srf.html" title="en">en</a></span>-->
      <div style="clear:both"></div>
    </div>

    <div id="menu">
        <div class="webgen-menu-vert "><ul><li ><a href="../index.html" title="Home">Home</a></li><li class="webgen-menu-submenu"><a href="../install/index.html" title="Install">Install</a></li><li class="webgen-menu-submenu"><a href="../ms/index.html" title="MS">MS</a></li><li class="webgen-menu-submenu webgen-menu-submenu-inhierarchy"><a href="./index.html" title="SpecID">SpecID</a><ul><li class="webgen-menu-item-selected"><a href="./srf.html" title="SRF">SRF</a></li><li ><a href="./spec_id.html" title="SpecID">SpecID</a></li><li class="webgen-menu-submenu"><a href="fir/index.html" title="FIR">FIR</a></li></ul></li><li class="webgen-menu-submenu"><a href="../tutorial/index.html" title="Tutorials">Tutorials</a></li></ul></div>
        <a style="font-size:130%; padding-left:20px" href="rdoc/index.html">rdoc</a>
        <br/>
        <a style="font-size:85%; padding-left:20px" href="http://rubyforge.org/projects/mspire/">Rubyforge Project Page</a>
        <br/>
        <br/>
        <br/>
        <br/>
        <a href="http://www.ruby-lang.org/en/"><img style="padding-left:20px" src=../images/ruby_logo_small.png border="0" alt="Ruby Programming Language"/></a>
    </div>

    <div id="body">
      <h1>Object Model</h1>

<p>SRFGroup mixes in SpecID and itself contains a collection of SRF objects.</p>

<p><img src="../images/srfgroup_object_model.png" alt="SRFGroup" title="SRGGroup object model"/></p>

<p>Filled diamond represents composition.  Lines represent associations.</p>

<h1>Examples</h1>

<h2>Creating an SRFGroup object</h2>

<h3>Creating with the SpecID interface:</h3>

<p>If you use the SpecID module to read in your srf file, you will always get an SRFGroup object.  The method takes a lot of different input, each outputing an SRFGroup object (which mixes in SpecID)</p>

<pre><code>require "spec_id" 

# output is the same for any of these instantiations: an SRFGroup object!
specid = SpecID.new(["file1.srf", "file2.srf"]) # array of srf files
specid = SpecID.new("file1.srf")                # single srf file
specid = SpecID.new("file.srg")                 # an srf group file
</code></pre>

<p>(A .srg file is a text file with .srf path names.  See <a href="srg.html">srg files</a> for more explanation)</p>

<h3>Creating with the SRFGroup object</h3>

<p>You may directly create the SRFGroup object.  It is in all ways identical to the object created with the SpecID interface (indeed, the SpecID interface calls this initializer):</p>

<pre><code>srfg = SRFGroup.new(["file1.srf", "file2.srf"])  # only takes an array
</code></pre>

<p>One would expect sequest results to be within the precursor mass tolerance
specified in the sequest.params file used for the search.  However, .srf files
contain all hits, even if they don't pass this filter.  By default, mspire
filters sequest hits based on the precursor mass tolerance specified in the
sequest.params file and adjusts hit values accordingly (see deltacn section).  This filtering is only performed at the level of a SRFGroup object.</p>

<pre><code># filters hits by default
srfg = SRFGroup.new(["file1.srf", "file2.srf"])

# no filtering:
srfg = SRFGroup.new(["file1.srf", "file2.srf"], false)  # &lt;- notice the false!
</code></pre>

<h2>Accessing Information</h2>

<h3>SRF object</h3>

<pre><code>srf.peps  # =&gt; Array of SRF::OUT::Pep objects
srf.prots # =&gt; Array of SRF::OUT::Prot objects

srfg.srfs.each do |srf|
  srf.version           # srf file version
  srf.header            # SRF::Header object
  srf.base_name         # short identifier of the run
  srf.params            # Sequest::Params object
  srf.filtered_by_precursor_mass_tolerance    # =&gt; have results been filtered?
end
</code></pre>

<h3>DTA</h3>

<pre><code>srfg.srfs.each do |srf|
  srf.dta_files.each do |dta|
    dta.mh          # observed M+H+
    dta.dta_tic     # total ion count
    dta.num_peaks   # the number of peaks
    dta.charge      # assumed charge
    dta.ms_level    # ms level

    dta.peaks       # a byte array of floats
    # to extract out the peaks:
    dta.peaks.unpack("e*")  # =&gt; an array of floats
  end
end
</code></pre>

<h3>Peptide and Protein Hits</h3>

<pre><code># the easy way:
srfg.peps  # =&gt; SRF::OUT::Pep objects
srfg.prots # =&gt; SRF::OUT::Prot objects

# or the long way:
srfg.srfs.each do |srf|
  srf.out_files.each do |out|
    out.hits.each do |pep|
      pep.mh                    # theoretical M+H+
      pep.xcorr                 # Xcorr
      pep.sequence              # A.PEPTIDE.C 
      pep.aaseq                 # PEPTIDE
      pep.deltacn_orig          # the (classic) deltacn value given in the srf file
      pep.deltacn_orig_updated  # the latest updated (classic) deltacn value
      pep.deltacn               # latest updated new definition deltacn
      pep.prots.each do |prot|
        prot.reference
      end
    end
  end
end
</code></pre>

<h2>deltacn</h2>

<h4>Classic deltacn</h4>

<p>The classic Deltacn ('delta correlation normalized') is the normalized
difference between the hit's Xcorr and the best hit's Xcorr.  Thus, the top
hit receives a 0.0.  If the top hit has an Xcorr of 2.0 and the hit of
interest has an Xcorr of 1.0, the normalized difference between the two will
be (2.0 - 1.0) / 2.0 = 0.5 .  </p>

<p>The classic deltacn found in the raw srf file is accessed (assuming a
SRF::OUT::Pep object named <code>pep</code>): </p>

<pre><code>pep.deltacn_orig
</code></pre>

<p>If the deltacn has been recalculated (after precursor tolerance filtering) the
new value will be stored in</p>

<pre><code>pep.deltacn_orig_updated
</code></pre>

<p>If no filtering has been performed, <code>pep.deltacn_orig</code> and
<code>pep.deltacn_orig_updated</code> will be equal.</p>

<h4>New deltacn</h4>

<p>A long time ago, the ISB folks (creator's of the Trans-Proteomic Pipeline)
only considered top hits (at least with the out2summary software), and the
classic deltacn doesn't say much about the best hit (since it's always zero).
So they took the value of the 2nd best hit and called it the 'deltacn'.</p>

<p>In the Bioworks Browser software, deltacn is redefined as the deltacn of the
next best hit.  So the top hit gets the deltacn of the 2nd best hit (same as
the ISB folks), the 2nd best hit gets the deltacn of the 3rd best hit and so
on.  The last hit gets a deltacn of 1.1.</p>

<p>The New deltacn (always updated when filtering by precursor tolerance) is accessed</p>

<pre><code>pep.deltacn
</code></pre>

<h2>Array access to attributes</h2>

<p>Many of these objects are Arrayclass objects and so they are really arrays.
This knowledge can be handy for accessing lots of information at once (can be
much faster, too):</p>

<pre><code># grab all values in one shot (order is important!):
(mh, deltacn_orig, sp, xcorr, id, num_other_loci, rsp, ions_matched, 
ions_total, sequence, prots, deltamass, ppm, aaseq, base_name, first_scan, 
last_scan, charge, srf, deltacn, deltacn_orig_updated) = pep

(deltacn_orig, deltacn_orig_updated, deltacn) = pep.values_at(1, -1, -2)
</code></pre>
    </div>

    <div id="footer" class="bar">
      Last update: <i>Monday, August 18 10:50:23 MDT 2008</i>
    </div>
  </body>
</html>
